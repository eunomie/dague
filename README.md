# Dague

Build Go projects, better. Based on [`dagger`](https://dagger.io).

## Why?

Especially when you're working on multiple projects, there's always the question of the tooling, the different version
of all the tools, do you have all the needed requirements, etc.

## Usage in Other Projects

You can use the default `dague` generated tool from the GitHub release page. It will give you the basic, the default tools.
You just have to copy it and run it.

But it has been done in a way to be easily extensible to support your own project. For instance, maybe you have a specific
target to build. Or you need to set some variable. Or anything else.

One of the key idea behind `dague` is to be a helper to build your own custom tool, for your own need. You just have to
pick the targets you want, and add yours.

Two different integrations are provided by default:

- one based on `kong`, to build CLIs easily
- one based on `mage`, if you want something more `make` style

### Kong

[`kong`](./kong) package and sub packages provides you commands and sub commands to build your own CLI.

For instance, look at [`cmd/dague/main.go`](./cmd/dague/main.go) to see how to create a CLI with the default targets:

```go
package main

import (
	"github.com/eunomie/dague/kong"
	"github.com/eunomie/dague/kong/gofumpt"
	"github.com/eunomie/dague/kong/golang"
	"github.com/eunomie/dague/kong/lint"
)

type (
	CLI struct {
		Lint    lint.Lint       `cmd:""`
		Gofumpt gofumpt.Gofumpt `cmd:""`
		Go      golang.Golang   `cmd:""`
	}
)

func main() {
	kong.Run(&CLI{})
}
```

That's all you need to have this CLI:

```text
Usage: dague <command>

Flags:
  -h, --help    Show context-sensitive help.

lint
  lint govuln
    checks vulnerabilities in Go code

gofumpt
  gofumpt print
    print result of gofumpt

  gofumpt write
    write result of gofumpt to existing files

golang
  go deps
    download go modules

  go mod
    run go mod tidy and export go.mod and go.sum files

  go test
    run go tests

  go doc
    generate to documentation in README.md files

  go build <in>
    compile go code and export it for the local architecture

  go cross <in>
    compile go code and export it for multiple architectures

Run "dague <command> --help" for more information on a command.
```

### Mage

The same way as with `kong`, you can create your own tool using `mage`.

Here is a `magefile` example that will provide all the default tools:

```go
//go:build mage

package main

import (
	//mage:import
	_ "github.com/eunomie/dague/mage/golang"
	//mage:import
	_ "github.com/eunomie/dague/mage/lint"
	//mage:import
	_ "github.com/eunomie/dague/mage/gofumpt"
)
```

And here is the corresponding mage targets:

```text
Targets:
  go:checkDoc      verifies the documentation is up-to-date
  go:cross         compiles go code from target and export it into dist/ for multiple architectures (linux|darwin|windows)/(amd64|arm64)
  go:deps          downloads go modules
  go:doc           generates go documentation in README.md files
  go:local         compiles go code from target and export it into dist/ folder for the local architecture
  go:mod           runs go mod tidy and export go.mod and go.sum files
  go:test          runs go tests
  gofumpt:print    runs gofumpt and print the recommended changes
  gofumpt:write    runs gofumpt and write the recommended changes
  lint:govuln      checks vulnerabilities in Go code
```

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# dague

```go
import "github.com/eunomie/dague"
```

## Index

- [Variables](<#variables>)
- [func ApkInstall(packages ...string) dagger.ContainerExecOpts](<#func-apkinstall>)
- [func AptInstall(cont *dagger.Container, packages ...string) *dagger.Container](<#func-aptinstall>)
- [func Exec(ctx context.Context, cont *dagger.Container, opts dagger.ContainerExecOpts) error](<#func-exec>)
- [func ExecCont(ctx context.Context, src *dagger.Container, opts dagger.ContainerExecOpts) (*dagger.Container, error)](<#func-execcont>)
- [func ExecOut(ctx context.Context, src *dagger.Container, opts dagger.ContainerExecOpts) (string, string, error)](<#func-execout>)
- [func ExportGoMod(ctx context.Context, cont *dagger.Container, contDir, exportDir string) error](<#func-exportgomod>)
- [func GoInstall(packages ...string) dagger.ContainerExecOpts](<#func-goinstall>)
- [func GoModDownload() dagger.ContainerExecOpts](<#func-gomoddownload>)
- [func GoModFiles(c *dagger.Client) *dagger.Directory](<#func-gomodfiles>)
- [func GoModTidy() dagger.ContainerExecOpts](<#func-gomodtidy>)
- [func RunInDagger(ctx context.Context, do func(*dagger.Client) error) error](<#func-runindagger>)


## Variables

```go
var goModFiles = []string{"go.mod", "go.sum"}
```

## func ApkInstall

```go
func ApkInstall(packages ...string) dagger.ContainerExecOpts
```

ApkInstall runs the apk add command with the specified packaged, to install packages on alpine based systems. Example:

```
c.Container().From("alpine").Exec(ApkInstall("build-base"))
```

## func AptInstall

```go
func AptInstall(cont *dagger.Container, packages ...string) *dagger.Container
```

AptInstall runs apt\-get to install the specified packages. It updates first, install, then clean and remove apt\-get lists. Example:

```
dague.AptInstall(c.Container().From("debian"), "gcc", "git")
```

## func Exec

```go
func Exec(ctx context.Context, cont *dagger.Container, opts dagger.ContainerExecOpts) error
```

Exec runs the specified command and check the error and exit code. Example:

```
err := dague.Exec(ctx, c.Container().From("golang"), dagger.ContainerExecOpts{
    Args: []string{"go", "build"},
})
```

## func ExecCont

```go
func ExecCont(ctx context.Context, src *dagger.Container, opts dagger.ContainerExecOpts) (*dagger.Container, error)
```

ExecCont runs the specified command and check the error and exist code. Returns the container and the error if exists. Example:

```
cont, err := dague.ExecCont(ctx, c.Container().From("golang"), dagger.ContainerExecOpts{
    Args: []string{"go", "build"},
})
```

## func ExecOut

```go
func ExecOut(ctx context.Context, src *dagger.Container, opts dagger.ContainerExecOpts) (string, string, error)
```

ExecOut runs the specified command and return the content of stdout and stderr. Example:

```
stdout, stderr, err := dague.ExecOut(ctx, c.Container().From("golang"), dagger.ContainerExecOpts{
    Args: []string{"go", "build"},
})
```

## func ExportGoMod

```go
func ExportGoMod(ctx context.Context, cont *dagger.Container, contDir, exportDir string) error
```

ExportGoMod reads the default go mod tiles from the specified internal dir and export them to the host.

## func GoInstall

```go
func GoInstall(packages ...string) dagger.ContainerExecOpts
```

GoInstall installs the specified go packages. Example:

```
c.Container().From("golang").Exec(GoInstall("golang.org/x/vuln/cmd/govulncheck@latest"))
```

## func GoModDownload

```go
func GoModDownload() dagger.ContainerExecOpts
```

GoModDownload runs the go mod download command.

## func GoModFiles

```go
func GoModFiles(c *dagger.Client) *dagger.Directory
```

GoModFiles creates a directory containing the default go mod files.

## func GoModTidy

```go
func GoModTidy() dagger.ContainerExecOpts
```

GoModTidy runs the go mod tidy command.

## func RunInDagger

```go
func RunInDagger(ctx context.Context, do func(*dagger.Client) error) error
```

RunInDagger initialize the dagger client and close it. In between it runs the specified function. Example:

```
dague.RunInDagger(ctx, func(c *dagger.Client) error {
    c.Container().From("alpine")
})
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->